*   mov 移动 第二个操作数移动到第一个操作数
*   add 加 第二个操作数加到第一个操作数
*   sub 减 第二个操作数减去第一个操作数

![image-20240208152202509](./assets/image-20240208152202509.png)

#### mul 乘

mul bl

如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认AX中，一个放在16位reg或内存单元中。

计算结果：8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中，低位放在AX中。

#### div 除

如果除数是8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，DX存高16位，AX存放低16位。

计算结果：如果除数为8位，则AL存储商，AH存储余数；如果除数是16位，AX存储商，DX存储余数。

#### and / or 逻辑运算

*   and 按位相与存放到前面的操作数
*   or 按位相或存放到前面的操作数

#### shl / shr 位移

*   shl 左移运算
*   shr 右移运算
*   rol 循环左移
*   ror 循环右移

#### inc / dec 自增减

*   inc ax 自增1
*   dec ax 自减1

#### xchg 交换指令

xchg AX,BX 两个操作数互换

#### jmp

jmp 1000:3跳转到地址1000:3
jmp bx 跳转到CS为段地址，bx为偏移地址

#### pop / push 栈操作

pop ax;
push [0];  段地址默认DS

>   栈指针  SS:SP

#### cmp 比较

cmp功能相当于减法指令，只是不保存结果。

cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别标志寄存器位来得知比较结果

>   cmp 操作对象1,操作对象2

#### je / jne / jb / jnb / ja / jna 对比较结果进行处理

*   je 等于则转移
*   jne 不等于则转移
*   jb 低于则转移
*   jnb 不低于则转移
*   ja 高于则转移
*   jna 不高于则转移

>   bean

*   jmp word ptr
*   jmp dword ptr
*   jcxz   if((cx)==0) jmp short;

#### 跳转到标号处执行执行指令

*   jmp short   实现段内短转移，对IP的修改范围 为-128\~127
*   jmp near    类似于jmp short
*   jmp far       远转移

~~~ assembly
jmp short s
~~~



#### loop 循环

CPU在执行loop指令的时候

1.   (cx)=(cx)-1
2.   判断cx中的值，不为零则转至标号执行程序，如果为零，则向下执行

>   CX中存放循环的次数

~~~ assembly
assume cs:codesg
codesg segment
	mov cx,100;
	s:add bx,cx;
	loop s;
	int 21H;
codesg ends
end
~~~

#### call、ret 函数调用

~~~ assembly
assume cs:codesg
codesg segment
	mov ax,0000H;
	mov bx,0001H;
	call s;
	mov cx,0001H;
	int 21H;
s:	mov ax,bx;
	ret;
codesg ends
end
~~~

