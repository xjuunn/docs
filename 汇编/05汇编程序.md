# 汇编程序

[toc]

## 定义数据

*   BYTE db 8位
*   WORD dw 16位
*   DWORD dd 32位
*   QWORD qd 64位

“dw”即“define word”

## 定义段

~~~ assembly
assume cs:codesg,ds:data,ss:stack
data segment
	db 'hello world'
	dw 123H,0abcH
data ends
stack segment
	db 10 dup (0);
stack ends
codesg segment
	start:
	mov ax,3;
	mov cx,11;
codesg ends
end start
~~~

>   “hello word” 应该用db一个字节来存储，如果用dw来存储，会报错
>
>   段的别名直接使用可以代表段地址
>
>   数据也可以进行标号
>   ~~~ assembly
>   data segment 
>   	arr db 12,34
>   data ends
>   ~~~
>

#### 取偏移地址 offset

offset 取得标号的偏移地址

~~~ assembly
assume cs:codesg
codesg segment
start:	mov ax,offset start;
s:		mov ax,offset s;
codesg ends
end start
~~~

eg: 实现对代码的转移

~~~ assembly
assume cs:codesg
codesg segment
s:	mov ax,bx;
	mov si,offset s;
	mov di,offset s0;
	mov dx,cs:[si];
	mov cs:[di],dx;
s0:	nop;
	nop;
cosesg ends
ends
~~~

#### 取段地址 SEG

SEG 变量名/标号

取变量名或标号所在的段的段首地址

#### 求变量名或标号的类型 TYPE

TYPE 变量名或标号

返回一个数值。如TYPE加在变量名前，返回改变量的类型属性；若加在标号前，返回该变量的距离属性。

|      | 属性  | 类型值 |
| ---- | ----- | ------ |
| 变量 | BYTE  | 1      |
| 变量 | WORD  | 2      |
| 变量 | DWORD | 4      |
| 标号 | NEAR  | -1     |
| 标号 | FAR   | -2     |

#### PTR 运算符

类型 PTR 表达式

用于指定变量、标号或地址表达式的类型属性，新的类型只能在当前指令内有效。

## 伪指令

### 符号定义伪指令(赋值语句)

#### 等值伪指令 EQU

符号名 EQU 表达式

将表达式的值赋值给符号名

>   符号名一旦被EQU定义，就不能在赋值，即不能用EQU再为符号名重新赋值。

#### 等号伪指令 =

符号名 = 表达式

将表达式的值赋值给符号名

>   可以再程序中不同的地方多次使用以重新为符号名赋值。

### 数据定义伪指令

#### 数值表达式 DB、DW、DD、DQ、DT

[变量名] DB 表达式; 定义字节

[变量名] DW 表达式; 定义字

[变量名] DD 表达式; 定义双字

[变量名] DQ 表达式; 定义8个字节

[变量名] DT 表达式; 定义10个字节

#### 定义 ASCII 字符串

字符串必须用引号括起来，并且不超过256个字符，他们再内存中按地址递增顺序自左向右依次存放字符的ASCII码。

STRING DB ‘ABC’

#### 预留存储单元 ？

存储单元中不预置确定的值，常用来预留存储单元，存放程序的中间结果或最终结果。

#### 重复定义子句 DUP

可以为若干个重复的数据分配存储单元。

n DUP (表达式)

n: 重复次数  表达式: 重复的内容

TAB DB 100 DUP (5)

>   1.   DUP操作可以嵌套
>   2.   在定义变量及存储单元的同时，也定义了他们的类型属性。同一数据定义语句所定义的各存储单元具有相同的类型。

### 段定义伪指令 SEGMENT

段名 SEGMENT [定位类型] [组合类型] [‘类别名’]

 把模块化范围若干个逻辑段

每个SEGMENT/ENDS可以定义一个逻辑段

### 段寄存器说明伪指令 ASSUME

ASSUME 段寄存器:段名 [,段寄存器:段名…]

向汇编程序指示当前各段所用的段寄存器，设定段寄存器与段的对应关系

>   1.   本伪指令只是指示各逻辑段使用寄存器的情况，并没有对段寄存器内容进行装填。段寄存器的实际值还要由MOV指令在程序中装填数据。
>   2.   也可用来取消段寄存器与段之间的对应关系(用NOTHING)，然后再建立新的的对应关系。

### 过程定义伪指令 PROC

过程是程序中的一部分，它可以被程序调用。每次可调用一个过程，当过程中的指令执行完后，控制返回调用它的地方。过程的定义是用过程定义伪指令完成的。

过程名 PROC [NEAR/FAR]
	.
	.
	.

RET
过程名 ENDP

