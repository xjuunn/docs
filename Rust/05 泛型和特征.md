[toc]

# 泛型和特征

泛型和特征是Rust中最重要的抽象类型

## 泛型 Generics

泛型参数一般用<kbd>T</kbd>表示（T是type的首字母）,也可以用表达某种含义的字母表示。

>   [!warning]
>
>   使用泛型参数，必须在使用前对其进行声明

~~~ rust
fn add<T:std::ops:Add<Output = T>>	(a:T,b:T) -> T {
    a + b
}
~~~

### 结构体中使用泛型

~~~ rust
struct Point<T> {
    x: T,
    y: T,
}
fn main() {
    let integer = Point {x:5, y:10};
    let float = Point {x:1.0,y:4.0};
}
~~~

>   [!warning]
>
>   *   提前声明，跟泛型函数定义类似，在使用泛型之前必须要进行声明Point\<T\>
>   *   x 和 y 是相同的类型

如果想要xy的类型不同，就要使用不同的泛型参数

~~~ rust
struct Point<T,U> {
    x: T,
    y: U,
}
fn main() {
    let p = Point {x:1,y:1.1};
}
~~~

### 枚举中使用泛型

~~~ rust
enum Option<T> {
    Some(T),
    None,
}
~~~

Option\<T\>是一个拥有泛型T的枚举类型，它的炖个成员是Some(T)，存放了一个类型为T的值。

### 方法中使用泛型

~~~ rust
struct Point<T> {
    x: T,
    y: T,
}
impl<T> Point<T> {
    fn x(&self) ->  &T {
        &self.x
    }
}
fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c'};

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
~~~

### 为具体的泛型类型实现方法

~~~ rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
~~~

### const 泛型

~~~ rust
fn display_array<T:std::fmt::Debug>(arr:&[T]) {
    println!("{:?}",arr);
}
fn main() {
    let arr:[i32;3] = [1,2,3];
    display_array(&arr);
    let arr:[i32,2] = [4,5];
    display_array(&arr);
}
~~~

为T加一个限制`std::fmt::Debug`,该限制表明T可以在println!(“{:?}”,arr) 中，因为{:?}的形式格式化输出需要arr实现该特征

~~~ rust
fn display_array<T:std::fmt::Debug,const N:usize>(arr:[T;N]) {
    println!("{:?}",arr);
}
fn main() {
    let arr: [i32;3] = [1,2,3];
    display_array(arr);
    let arr: [i32;2] = [1,2];
    display_array(arr);
}
~~~

定义了一个类型为[T;N]的数组，其中T是一个基于类型的泛型参数，N是一个基于值的泛型参数，他是用来替代数组的长度。

N 就是const泛型，定义的语法是const N:usize，表示const泛型N，他的值是类型是usize。

#### const 泛型表达式

~~~ rust
// 目前只能在nightly版本下使用
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn something<T>(val: T)
where
    Assert<{ core::mem::size_of::<T>() < 768 }>: IsTrue,
    //       ^-----------------------------^ 这里是一个 const 表达式，换成其它的 const 表达式也可以
{
    //
}

fn main() {
    something([0u8; 0]); // ok
    something([0u8; 512]); // ok
    something([0u8; 1024]); // 编译错误，数组长度是1024字节，超过了768字节的参数长度限制
}

// ---

pub enum Assert<const CHECK: bool> {
    //
}

pub trait IsTrue {
    //
}

impl IsTrue for Assert<true> {
    //
}
~~~

### 泛型的性能

在Rust中，泛型是零成本的抽象，意味着在使用泛型时，完全不用担心性能上的问题

但是，使用泛型，会损失编译速度和增大了最终生成文件的大小。

Rust通过编译时进行了泛型代码的***单态化***来保证效率。

## 特征 Trait

和接口类似

特征定义了一组可以被共享的行为，只要实现了特征，就能使用这组行为。

~~~ rust
fn add<T:std::ops::Add<Output = T>>(a:T,b:T) -> T {
    a + b
}
~~~

### 定义特征

