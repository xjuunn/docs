[toc]

# 浏览器渲染原理

[Exploring the browser rendering process](https://abhisaha.com/blog/exploring-browser-rendering-process)

[浏览器渲染原理](https://segmentfault.com/a/1190000042909353)

浏览器的渲染过程是多线程、进程和阶段的复杂编排，可以将原始的HTML、CSS和JS转换为屏幕上的交互元素。

## 1. 导航和网络

当在浏览器的地址栏中数据URL并按<kbd>Enter</kbd>时，该过程启动。

假设访问的地址是`https://example.com`，浏览器首先会通过DNS将域名转换为IP地址。

1. 输入URL地址，并按回车
2. 启动DNS查找 `example.com`
3. 优先在本地缓存中查找，未找到
4. 查询根域名服务器 `.com`顶级域名信息
5. 收到权威域名服务器信息
6. 解析完成，获取到对应的服务器IP

现在浏览器可以与托管网站的服务器建立连接。通过TCP握手建立连接。

> [!tip]
>
> 域名服务器是用于查找与域名关联的IP地址的专用服务器。

## 2. TCP/TLS 握手

TCP三次握手

* SYN：客户端向服务器发送同步(SYN)数据包以启动连接。
* SYN-ACK：服务器使用确认(SYN-ACK)数据包向客户端进行响应。
* ACK：客户端向服务器发送确认(ACK)以完成握手。

这时服务器与浏览器简历了连接，但是为了建立https的安全连接，需要再进行TLS握手。

TLS握手的种类

1. Hello Message：客户端发送`ClientHello`以启动握手，服务器使用`ServerHello`及其数字证书进行响应。
2. Key Exchange：服务器可以发送密钥交换信息，而客户端使用自己的密钥交换信息进行响应。
3. Cipher Spec：客户端发送一条`CipherSpec`信息以切换到协商加密，并在其后发送Finished信息。
4. Server Finalization：服务器使用自己的`CipherSpec`消息和Finished信息进行回复，完成握手并建立安全连接。

> [!tip]
>
> SSL或安全套接字层是为HTTP开发的原始安全协议。SSL现在已经被TLS(传输层安全)取代。

直到TLS握手完成，没有传输任何实际内容或应用程序数据，服务器仅确认连接并建立了安全通道。只有在TLS握手完成并且双方交换了Finished消息后，才能开始安全地发送和接收加密内容。

## 3. HTTP请求/响应周期

浏览器请求网站内容，服务器处理请求并返回响应；后端开发人员负责处理请求，前端开发人员获取响应信息。

> TTFB（Time to First Byte）：TTFB计算的是整个延迟的往返时间，从设备到服务器，再从服务器到设备的时间。

浏览器在收到第一个字节后，响应将继续加载。服务器仍在处理请求并将剩余数据发送回客户端。从这时起，浏览器开始处理响应。

## 4. 分词化

浏览器开始解析HTML响应。读取HTML原始二进制数据，并根据文件的指定编码，将它们转换为单个字节，如`UTF-8`：

~~~ 
01001000 01010100 01001101 01001100
~~~

> [!tip]
>
> 每组8位表示一个字节，每个字节都可以转换为字符、符号或指令。
>
> 例如：在 UTF-8 编码中，字母 A 的二进制序列为01000001。 字母 B 为 01000010

浏览器将字符串转换为不同的标签并对其进行分组。例如\<html\>\</html\>和\<body\>\</body\>，每一个标签都是一个有意义的单元，表示HTML组件。

## 5. DOM树构建

DOM(文档对象模型)树是HTML文档结构的分层表示形式。他将元素表示为节点数，每个节点表示文档中的一个元素、属性或文本内容。

每次浏览器呈现网页时，它都会经历多步骤的过程：将HTML字节解析为字符，识别标签，将他们转换为节点，最后构建DOM数。虽然DOM数定义了HTML元素的结构和关系，但是并不决定视觉外观，因为这是CSSOM的作用。

## 6. CSSOM树创建

CSS对象模型时应用于HTML文档和CSS样式的表示形式，它类似于DOM树，但是表示的是CSS样式。

CSSOM用于计算文档中每个元素的最终样式。浏览器将这些样式解析为简化、内存高效且优化的数据结构。此结构旨在有效地组织样式规则，从而允许根据匹配的选择器快速检索和应用样式。

构建DOM和CSSOM后，浏览器就可以开始创建渲染树了。

## 7. 渲染树创建

渲染树是DOM和CSSOM树的组合。它表示页面的视觉结构，包括布局和样式信息。

渲染树仅包含在屏幕上显示的元素，它为每一个元素计算了样式和布局信息，使浏览器能够呈现页面。

## 8. 布局

布局过程计算页面上每一个元素确切的位置和大小。根据渲染树确定每一个元素的尺寸、边距、填充、边框和位置。

## 9. 绘制

在绘制阶段，浏览器获取结构化布局信息并将每个元素绘制到屏幕上。这个过程将填充颜色并应用图像、边框、阴影和其他的视觉样式。绘制顺序基于堆叠上下文，确保z-index和其他的属性正确分层元素。

绘制过程经过优化，以最大限度地减少需要重回的像素数。浏览器使用分层、合成和缓存等技术来有效地呈现页面。



> [!caution]
>
> 不同的浏览器使用不同的渲染引擎，例如Blink(Chrome)、WebKit(Safari)、和Gecko(Firefox)。
>
> 这些引擎可能具有不同的性能特征和兼容性。某些CSS功能或JS只在一个引擎中受支持。
>
> 不同的引擎会将其默认样式应用于HTML元素

## 关于JavaScript

浏览器在解析HTML的工程中，遇到了script元素就停止构建DOM树，转而下载javascript代码，并执行javascript脚本，直到javascript脚本执行结束后，才会继续解析HTML，构建DOM树。

这么做是因为Javascript可能需要操作DOM，如果等待DOM构建完成并且渲染后再执行Javascript，会造成严重的回流和重绘，影响页面性能。

但是这么做会带来新的问题，比如使用vue或者React开发时，js文件过大，会造成页面卡顿，在脚本下载和执行完成之前，页面上什么都看不到。

为了解决这个问题，script元素提供了两个属性：defer和async

## defer和async

### defer

defer属性告诉浏览器不要等待脚本下载，而是继续解析HTML，构建DOM树。脚本会由浏览器进行下载，但是不会阻塞DOM树的构建过程。

DOMContentLoaded事件会等待defer中的代码执行完成。

defer脚本是按顺序执行的

> defer仅适用于外部脚本，对于script默认内软会被忽略

### async

async能够让脚本完全独立，浏览器不会因async脚本而阻塞，但是async不能保证顺序，它是独立下载、独立运行，不会等待其他脚本。

async不能保证执行的顺序，async不能保证在DOMContentLoaded事件之前或者之后执行。

> [!tip]
>
> defer通常用于需要在文档解析后操作DOM的js代码，并且多个脚本文件有执行顺序要求。
>
> async通常用于独立的脚本，对其他脚本甚至DOM没有依赖。
